import os, sys, json, uuid, threading, time, requests, tkinter as tk
from tkinter import messagebox, simpledialog, font
from PIL import Image, ImageTk, ImageDraw
import pygame
import math, random, io


# --- Constants ---
GUILD_ID = "1402622761246916628"
ROLE_ID = "1404221578782183556"
ACTIVATION_FILE = "activation_data.json"
DEFAULT_REPLY_DELAY = 8

# --- Machine ID (MAC address) ---
def get_machine_id():
    return f"{uuid.getnode():x}"

# --- Save/Load activation info ---
def save_activation(token, machine_id):
    with open(ACTIVATION_FILE, "w") as f:
        json.dump({"token": token, "machine_id": machine_id}, f)

def load_activation():
    if not os.path.isfile(ACTIVATION_FILE):
        return None
    try:
        with open(ACTIVATION_FILE, "r") as f:
            return json.load(f)
    except:
        return None

# --- Discord API calls ---
def get_user_id(token):
    url = "https://discord.com/api/v10/users/@me"
    headers = {"Authorization": token}
    try:
        r = requests.get(url, headers=headers)
        if r.status_code == 200:
            return r.json().get("id")
    except:
        pass
    return None

def has_role(token, user_id, guild_id, role_id):
    url = f"https://discord.com/api/v10/guilds/{guild_id}/members/{user_id}"
    headers = {"Authorization": token}
    try:
        r = requests.get(url, headers=headers)
        if r.status_code == 200:
            roles = r.json().get("roles", [])
            return role_id in roles
    except:
        pass
    return False

# --- Activation prompt ---
def prompt_for_token():
    root = tk.Tk()
    root.title("Activation Required")
    root.geometry("350x150")
    root.resizable(False, False)

    tk.Label(root, text="Enter your Discord User Token:", font=("Segoe UI", 12)).pack(pady=10)
    token_entry = tk.Entry(root, show="*", width=50)
    token_entry.pack(pady=5)
    status_label = tk.Label(root, text="", fg="red")
    status_label.pack()

    def try_activate():
        token = token_entry.get().strip()
        if not token:
            status_label.config(text="Token cannot be empty.")
            return
        status_label.config(text="Checking token and role...")
        root.update()
        user_id = get_user_id(token)
        if not user_id:
            status_label.config(text="Invalid token or failed to get user info.")
            return
        if not has_role(token, user_id, GUILD_ID, ROLE_ID):
            status_label.config(text="Token does not have required role.")
            return
        save_activation(token, get_machine_id())
        messagebox.showinfo("Activation", "Activation successful!")
        root.destroy()

    tk.Button(root, text="Activate", command=try_activate).pack(pady=10)
    root.mainloop()

def check_activation():
    data = load_activation()
    machine_id = get_machine_id()
    
    if data:
        token = data.get("token")
        saved_machine = data.get("machine_id")
        
        if saved_machine != machine_id:
            # Removed error popup, just prompt
            prompt_for_token()
            data = load_activation()
            if not data:
                sys.exit()
            token = data.get("token")
        else:
            user_id = get_user_id(token)
            if not user_id or not has_role(token, user_id, GUILD_ID, ROLE_ID):
                # Removed error popup, just prompt
                prompt_for_token()
                data = load_activation()
                if not data:
                    sys.exit()
                token = data.get("token")
                
        # Final verification before returning token
        user_id = get_user_id(token)
        if user_id and has_role(token, user_id, GUILD_ID, ROLE_ID):
            return token
        else:
            # Removed error popup, just exit silently
            sys.exit()
    
    else:
        prompt_for_token()
        data = load_activation()
        if not data:
            sys.exit()
        token = data.get("token")
        
        user_id = get_user_id(token)
        if user_id and has_role(token, user_id, GUILD_ID, ROLE_ID):
            return token
        else:
            # Removed error popup, just exit silently
            sys.exit()

pygame.mixer.init()

class DiscordBotGUI:
    TOKENS_FILE = "tokens.json"
    CHANNELS_FILE = "channels.json"

    def __init__(self, root):
        self.root = root
        self.root.title("Niggabutt User Token")
        self.root.geometry("900x700")
        self.root.resizable(False, False)

        # Fonts
        self.title_font = font.Font(family="Segoe UI", size=11, weight="bold")
        self.normal_font = font.Font(family="Segoe UI", size=10)
        self.mono_font = font.Font(family="Consolas", size=10)

        # Initialize variables
        self.tokens = {}
        self.channels = {}
        self.auto_reply_running = False
        self.send_running = False

        self.selected_token_name = None
        self.selected_channel_names = []

        # Setup Background Canvas with Gradient + Vignette + Particles
        self.bg_canvas = tk.Canvas(self.root, width=900, height=700, highlightthickness=0)
        self.bg_canvas.pack(fill="both", expand=True)

        self.gradient_image = self.create_gradient_image(900, 700)
        self.bg_photo = ImageTk.PhotoImage(self.gradient_image)
        self.bg_canvas.create_image(0, 0, image=self.bg_photo, anchor="nw")
        self.create_tint_overlay(900, 700)

        self.particles = []
        self.create_particles(100)
        self.animate_particles()

        # Overlay Frame for widgets (transparent background)
        self.main_frame = tk.Frame(self.root, bg="#1e1b29")
        self.main_frame.place(relx=0.03, rely=0.03, relwidth=0.94, relheight=0.94)

        # Setup GUI widgets on main_frame
        self.setup_gui()

        # Load saved tokens and channels
        self.load_data()

        # Bind token selection event
        self.token_var.trace_add("write", lambda *a: self.on_token_change())

        # Protocol handler for graceful shutdown
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)

        # Play opening sound if available
        self.play_opening_sound()

        # Apply theme/colors/fonts to all widgets
        self.apply_theme()

    # -------- Background & Visuals --------
    def create_gradient_image(self, width, height):
        base = Image.new('RGB', (width, height), "#1e1b29")
        draw = ImageDraw.Draw(base)
        for i in range(height):
            # Vertical gradient from rgb(90,62,153) to rgb(18,15,31)
            r = int(90 + (18 - 90) * (i / height))
            g = int(62 + (15 - 62) * (i / height))
            b = int(153 + (31 - 153) * (i / height))
            draw.line([(0, i), (width, i)], fill=(r, g, b))
        return base

    def create_tint_overlay(self, width, height):
        vignette = Image.new('RGBA', (width, height))
        draw = ImageDraw.Draw(vignette)
        for y in range(height):
            for x in range(width):
                dx = x - width / 2
                dy = y - height / 2
                dist = math.sqrt(dx * dx + dy * dy)
                max_dist = math.sqrt((width / 2) ** 2 + (height / 2) ** 2)
                alpha = int(min(150, max(0, (dist - max_dist * 0.6) / (max_dist * 0.4) * 150)))
                draw.point((x, y), fill=(0, 0, 0, alpha))
        self.vignette_photo = ImageTk.PhotoImage(vignette)
        self.bg_canvas.create_image(0, 0, image=self.vignette_photo, anchor="nw")

    def create_particles(self, count):
        for _ in range(count):
            p = {
                'x': random.uniform(0, 900),
                'y': random.uniform(0, 700),
                'radius': random.uniform(1, 3),
                'speed': random.uniform(0.01, 0.03),
                'angle': random.uniform(0, 2 * math.pi),
                'id': None,
                'base_y': 0
            }
            p['base_y'] = p['y']
            p['id'] = self.bg_canvas.create_oval(
                p['x'], p['y'], p['x'] + p['radius'] * 2, p['y'] + p['radius'] * 2,
                fill="#5a3e99", outline=""
            )
            self.particles.append(p)

    def animate_particles(self):
        for p in self.particles:
            p['angle'] += p['speed']
            offset = math.sin(p['angle']) * 15
            new_y = p['base_y'] + offset
            self.bg_canvas.coords(p['id'], p['x'], new_y, p['x'] + p['radius'] * 2, new_y + p['radius'] * 2)
        self.root.after(30, self.animate_particles)

    # -------- GUI Widgets Setup --------
    def setup_gui(self):
        frame = self.main_frame  # alias for convenience

        # Reply DM message & control (moved to top)
        tk.Label(frame, text="Reply DM Message:").grid(row=0, column=0, sticky="nw", pady=5, padx=5)
        self.reply_dm_entry = tk.Text(frame, height=3, width=70)
        self.reply_dm_entry.grid(row=0, column=1, columnspan=2, sticky="w", pady=5, padx=5)

        self.reply_dm_button = tk.Button(frame, text="Start Reply DM", command=self.toggle_reply_dm)
        self.reply_dm_button.grid(row=0, column=3, sticky="e", pady=5, padx=5)
        # Delay label and entry (default 8 seconds)
        tk.Label(frame, text="Reply Delay (seconds):").grid(row=1, column=0, sticky="w", pady=5, padx=5)
        self.reply_delay_entry = tk.Entry(frame, width=5)
        self.reply_delay_entry.insert(0, "8")  # default 8 seconds
        self.reply_delay_entry.grid(row=1, column=1, sticky="w", pady=5, padx=5)

        # Token input & menu
        tk.Label(frame, text="Token:").grid(row=1, column=0, sticky="w", padx=5, pady=5)
        self.token_entry = tk.Entry(frame, width=50)
        self.token_entry.grid(row=1, column=1, sticky="w", padx=5, pady=5)
        tk.Button(frame, text="Save Token", command=self.save_token).grid(row=1, column=2, sticky="w", padx=5, pady=5)

        self.token_var = tk.StringVar()
        self.token_menu = tk.OptionMenu(frame, self.token_var, ())
        self.token_menu.grid(row=1, column=3, sticky="w", padx=5, pady=5)

        # Channels input & checkboxes frame
        tk.Label(frame, text="Channel:").grid(row=2, column=0, sticky="w", padx=5, pady=5)
        self.channel_entry = tk.Entry(frame, width=50)
        self.channel_entry.grid(row=2, column=1, sticky="w", padx=5, pady=5)
        tk.Button(frame, text="Save Channel", command=self.save_channel).grid(row=2, column=2, sticky="w", padx=5, pady=5)

        self.channel_vars = {}
        self.channels_frame = tk.Frame(frame)
        self.channels_frame.grid(row=3, column=0, columnspan=4, sticky="w", pady=5, padx=5)

        # Message content
        tk.Label(frame, text="Message Content:").grid(row=4, column=0, sticky="nw", padx=5, pady=5)
        self.message_entry = tk.Text(frame, height=5, width=70)
        self.message_entry.grid(row=4, column=1, columnspan=3, sticky="w", padx=5, pady=5)

        # Delay and loop count
        tk.Label(frame, text="Delay (seconds):").grid(row=5, column=0, sticky="w", padx=5, pady=5)
        self.delay_entry = tk.Entry(frame, width=10)
        self.delay_entry.insert(0, "3")
        self.delay_entry.grid(row=5, column=1, sticky="w", padx=5, pady=5)

        tk.Label(frame, text="Loop Count (0=infinite):").grid(row=5, column=2, sticky="w", padx=5, pady=5)
        self.loop_entry = tk.Entry(frame, width=10)
        self.loop_entry.insert(0, "1")
        self.loop_entry.grid(row=5, column=3, sticky="w", padx=5, pady=5)

        # Control buttons
        tk.Button(frame, text="Start Sending", command=self.start_sending).grid(row=6, column=0, pady=10, padx=5)
        tk.Button(frame, text="Pause/Resume", command=self.pause_resume_sending).grid(row=6, column=1, pady=10, padx=5)
        tk.Button(frame, text="Stop Sending", command=self.stop_sending).grid(row=6, column=2, pady=10, padx=5)

        # Log output
        tk.Label(frame, text="Activity Log:").grid(row=7, column=0, sticky="nw", padx=5, pady=5)
        self.log_scrollbar = tk.Scrollbar(frame, orient=tk.VERTICAL)
        self.log_scrollbar.grid(row=7, column=4, sticky="ns", pady=5)

        self.log_text = tk.Text(frame, height=8, width=80, state=tk.DISABLED, yscrollcommand=self.log_scrollbar.set)
        self.log_text.grid(row=7, column=1, columnspan=3, sticky="w", padx=5, pady=5)
        self.log_scrollbar.config(command=self.log_text.yview)

        # User info (avatar + username)
        self.user_info_frame = tk.Frame(frame, bg="#1e1b29")
        self.user_info_frame.grid(row=8, column=1, columnspan=3, sticky="w", pady=(10, 0))

        self.avatar_label = tk.Label(self.user_info_frame, bg="#1e1b29")
        self.avatar_label.pack(side="left", padx=(0, 10))

        self.username_label = tk.Label(self.user_info_frame, text="", font=self.title_font, bg="#1e1b29", fg="#e0d7ff")
        self.username_label.pack(side="left")


    # -------- Theme/Colors --------
    def apply_theme(self):
        bg_color = "#1e1b29"
        fg_color = "#e0d7ff"
        entry_bg = "#2c2750"
        button_bg = "#5a3e99"
        button_fg = "#f0e9ff"
        log_bg = "#120f1f"
        menu_bg = "#2c2750"
        menu_fg = "#e0d7ff"

        self.root.configure(bg=bg_color)
        self.main_frame.configure(bg=bg_color)
        self.user_info_frame.configure(bg=bg_color)

        for lbl in [w for w in self.main_frame.winfo_children() if isinstance(w, tk.Label)]:
            lbl.configure(bg=bg_color, fg=fg_color, font=self.title_font)

        for w in [self.token_entry, self.channel_entry, self.delay_entry, self.loop_entry,
                  self.message_entry, self.log_text, self.reply_dm_entry]:
            w.configure(bg=entry_bg, fg=fg_color, insertbackground=fg_color, font=self.mono_font)

        for b in [w for w in self.main_frame.winfo_children() if isinstance(w, tk.Button)]:
            b.configure(bg=button_bg, fg=button_fg, activebackground="#7d5fff", activeforeground=button_fg,
                        relief="flat", font=self.title_font, cursor="hand2")
            b.bind("<Enter>", lambda e, btn=b: btn.configure(bg="#7d5fff"))
            b.bind("<Leave>", lambda e, btn=b: btn.configure(bg=button_bg))

        self.token_menu.configure(bg=button_bg, fg=button_fg, activebackground="#7d5fff", activeforeground=button_fg,
                                  font=self.title_font)
        self.token_menu["menu"].configure(bg=menu_bg, fg=menu_fg, font=self.normal_font)

        self.log_text.configure(bg=log_bg)

        self.username_label.configure(bg=bg_color, fg=fg_color)
        self.avatar_label.configure(bg=bg_color)

    # -------- Token & Channel Save/Load --------
    def save_token(self):
        token = self.token_entry.get().strip()
        if not token:
            self.log("‚ùå Token cannot be empty.")
            return
        name = simpledialog.askstring("Token Name", "Enter a name for this token:")
        if not name:
            self.log("‚ùå Token name cannot be empty.")
            return
        self.tokens[name] = token
        self.save_data()
        self.update_token_menu()
        self.token_var.set(name)
        self.log(f"‚úÖ Token '{name}' saved.")

    def save_channel(self):
        channel_id = self.channel_entry.get().strip()
        if not channel_id:
            self.log("‚ùå Channel ID cannot be empty.")
            return
        name = simpledialog.askstring("Channel Name", "Enter a name for this channel:")
        if not name:
            self.log("‚ùå Channel name cannot be empty.")
            return
        self.channels[name] = channel_id
        self.save_data()
        self.update_channel_checkboxes()
        self.log(f"‚úÖ Channel '{name}' saved.")

    def update_token_menu(self):
        menu = self.token_menu["menu"]
        menu.delete(0, "end")
        for name in self.tokens.keys():
            menu.add_command(label=name, command=lambda n=name: self.token_var.set(n))
        # Clear user info if current token not found
        if self.token_var.get() not in self.tokens:
            self.token_var.set("")
            self.clear_user_info()

    def update_channel_checkboxes(self):
        # Clear old checkboxes
        for widget in self.channels_frame.winfo_children():
            widget.destroy()
        self.channel_vars.clear()

        col = 0
        for name in sorted(self.channels.keys()):
            var = tk.BooleanVar()
            cb = tk.Checkbutton(self.channels_frame, text=name, variable=var, font=self.normal_font,
                                bg="#1e1b29", fg="#e0d7ff", selectcolor="#5a3e99", activebackground="#2c2750",
                                activeforeground="#e0d7ff", cursor="hand2")
            cb.grid(row=0, column=col, sticky="w", padx=5)
            self.channel_vars[name] = var
            col += 1

    def load_data(self):
        if os.path.exists(self.TOKENS_FILE):
            try:
                with open(self.TOKENS_FILE, "r") as f:
                    self.tokens = json.load(f)
            except Exception as e:
                self.log(f"‚ùå Failed to load tokens: {e}")
        if os.path.exists(self.CHANNELS_FILE):
            try:
                with open(self.CHANNELS_FILE, "r") as f:
                    self.channels = json.load(f)
            except Exception as e:
                self.log(f"‚ùå Failed to load channels: {e}")

        self.update_token_menu()
        self.update_channel_checkboxes()

    def save_data(self):
        try:
            with open(self.TOKENS_FILE, "w") as f:
                json.dump(self.tokens, f, indent=2)
            with open(self.CHANNELS_FILE, "w") as f:
                json.dump(self.channels, f, indent=2)
        except Exception as e:
            self.log(f"‚ùå Error saving data: {e}")

    # -------- Token Change & User Info Fetch --------
    def on_token_change(self):
        token_name = self.token_var.get()
        if token_name in self.tokens:
            self.selected_token_name = token_name
            token = self.tokens[token_name]
            threading.Thread(target=self.fetch_and_display_user_info, args=(token,), daemon=True).start()
        else:
            self.selected_token_name = None
            self.clear_user_info()

    def clear_user_info(self):
        self.avatar_label.config(image="")
        self.username_label.config(text="")

    def fetch_and_display_user_info(self, token):
        try:
            headers = {"Authorization": token}
            resp = requests.get("https://discord.com/api/v10/users/@me", headers=headers)
            if resp.status_code != 200:
                self.log(f"‚ùå Failed to get user info: {resp.status_code}")
                return
            user = resp.json()
            username = f"{user['username']}#{user['discriminator']}"

            avatar_hash = user.get("avatar")
            user_id = user.get("id")
            if avatar_hash:
                ext = "gif" if avatar_hash.startswith("a_") else "png"
                avatar_url = f"https://cdn.discordapp.com/avatars/{user_id}/{avatar_hash}.{ext}?size=128"
            else:
                discriminator_mod = int(user['discriminator']) % 5
                avatar_url = f"https://cdn.discordapp.com/embed/avatars/{discriminator_mod}.png"

            response = requests.get(avatar_url)
            if response.status_code == 200:
                image_data = response.content
                image = Image.open(io.BytesIO(image_data)).resize((64, 64))
                photo = ImageTk.PhotoImage(image)
                self.avatar_label.image = photo
                self.avatar_label.config(image=photo)
            else:
                self.avatar_label.config(image="")

            self.username_label.config(text=username)
        except Exception as e:
            self.log(f"‚ùå Error fetching user info: {e}")

    # -------- Logging --------
    def log(self, message):
        self.log_text.configure(state=tk.NORMAL)
        self.log_text.insert(tk.END, message + "\n")
        self.log_text.see(tk.END)
        self.log_text.configure(state=tk.DISABLED)

    # -------- Sending messages logic --------
    def start_sending(self):
        if self.send_running:
            self.log("‚ö†Ô∏è Already sending messages.")
            return
        token_name = self.token_var.get()
        if token_name not in self.tokens:
            self.log("‚ùå Please select a valid token.")
            return
        selected_channels = [name for name, var in self.channel_vars.items() if var.get()]
        if not selected_channels:
            self.log("‚ùå Please select at least one channel to send messages.")
            return

        message = self.message_entry.get("1.0", "end").strip()
        if not message:
            self.log("‚ùå Message content cannot be empty.")
            return

        try:
            delay = float(self.delay_entry.get())
            if delay < 0:
                raise ValueError
        except:
            self.log("‚ùå Invalid delay value.")
            return

        try:
            loop_count = int(self.loop_entry.get())
            if loop_count < 0:
                raise ValueError
        except:
            self.log("‚ùå Invalid loop count.")
            return

        self.selected_channel_names = selected_channels
        self.send_running = True

        threading.Thread(target=self.send_messages_loop,
                         args=(self.tokens[token_name], self.selected_channel_names, message, delay, loop_count),
                         daemon=True).start()
        self.log("‚ñ∂Ô∏è Started sending messages.")

    def send_messages_loop(self, token, channel_names, message, delay, loop_count):
        headers = {
            "Authorization": token,
            "Content-Type": "application/json"
        }
        count = 0
        while self.send_running and (loop_count == 0 or count < loop_count):
            for channel_name in channel_names:
                if not self.send_running:
                    break
                channel_id = self.channels.get(channel_name)
                if not channel_id:
                    self.log(f"‚ùå Channel '{channel_name}' ID not found.")
                    continue

                url = f"https://discord.com/api/v10/channels/{channel_id}/messages"
                try:
                    resp = requests.post(url, headers=headers, json={"content": message})
                    if resp.status_code in (200, 201):
                        self.log(f"‚úÖ Message sent to channel '{channel_name}'.")
                    else:
                        self.log(f"‚ùå Failed to send to channel '{channel_name}': {resp.status_code} {resp.text}")
                except Exception as e:
                    self.log(f"‚ùå Exception sending to '{channel_name}': {e}")

                # Wait delay seconds before next channel message
                for _ in range(int(delay * 10)):
                    if not self.send_running:
                        break
                    time.sleep(0.1)

            count += 1
        self.send_running = False
        self.log("‚èπÔ∏è Sending messages stopped.")

    def pause_resume_sending(self):
        if not self.send_running:
            self.log("‚ö†Ô∏è Not currently sending messages.")
            return
        self.send_running = not self.send_running
        status = "Resumed" if self.send_running else "Paused"
        self.log(f"‚ÑπÔ∏è {status} sending messages.")

    def stop_sending(self):
        if not self.send_running:
            self.log("‚ö†Ô∏è Not currently sending messages.")
            return
        self.send_running = False
        self.log("üõë Stopped sending messages.")

    # -------- DM Reply Logic --------
    def toggle_reply_dm(self):
        if self.auto_reply_running:
            self.auto_reply_running = False
            self.reply_dm_button.config(text="Start Reply DM")
            self.log("‚ÑπÔ∏è Stopped Reply DM loop.")
        else:
            token_name = self.token_var.get()
            if token_name not in self.tokens:
                self.log("‚ùå Please select a valid token.")
                return
            message = self.reply_dm_entry.get("1.0", "end").strip()
            if not message:
                self.log("‚ùå Reply DM message cannot be empty.")
                return
            try:
                delay = float(self.reply_delay_entry.get())
                if delay < 0:
                    raise ValueError()
            except ValueError:
                self.log("‚ùå Invalid delay value, must be a positive number.")
                return

            self.auto_reply_running = True
            self.reply_dm_button.config(text="Stop Reply DM")
            threading.Thread(target=self.dm_reply_loop, args=(self.tokens[token_name], message, delay), daemon=True).start()
            self.log("‚ñ∂Ô∏è Started Reply DM loop.")

    def dm_reply_loop(self, token, reply_message, delay=8):
        import asyncio
        import requests
        import websockets
        import json as jsjson
        import time

        API_BASE = "https://discord.com/api/v10"
        headers = {
            "Authorization": token,
            "Content-Type": "application/json"
        }
        replied_users = set()

        async def heartbeat(ws, interval):
            while True:
                await asyncio.sleep(interval / 1000)
                await ws.send(jsjson.dumps({"op": 1, "d": None}))

        async def run_gateway():
            gateway_url = "wss://gateway.discord.gg/?v=10&encoding=json"
            try:
                async with websockets.connect(gateway_url, max_size=2 ** 23) as ws:
                    hello = jsjson.loads(await ws.recv())
                    heartbeat_interval = hello['d']['heartbeat_interval']
                    asyncio.create_task(heartbeat(ws, heartbeat_interval))

                    identify_payload = {
                        "op": 2,
                        "d": {
                            "token": token,
                            "properties": {
                                "$os": "windows",
                                "$browser": "selfbot",
                                "$device": "selfbot"
                            },
                            "presence": {"status": "online"},
                            "compress": False,
                            "large_threshold": 50
                        }
                    }
                    await ws.send(jsjson.dumps(identify_payload))
                    self.log("‚úÖ Connected to Discord Gateway")

                    my_user_id = None

                    while self.auto_reply_running:
                        try:
                            msg = await ws.recv()
                            event = jsjson.loads(msg)

                            if event.get("t") == "READY" and my_user_id is None:
                                my_user_id = event["d"]["user"]["id"]
                                self.log(f"üß† Logged in as {my_user_id}")

                            if event.get("t") == "MESSAGE_CREATE":
                                msg_data = event["d"]
                                channel_id = msg_data["channel_id"]
                                author_id = msg_data["author"]["id"]

                                if author_id == my_user_id:
                                    continue

                                r = requests.get(f"{API_BASE}/channels/{channel_id}", headers=headers)
                                if r.status_code != 200:
                                    continue
                                channel_info = r.json()

                                if channel_info.get("type") == 1:  # DM channel
                                    if author_id not in replied_users:
                                        self.log(f"üì© New DM from {author_id}, replying in {delay} seconds...")
                                        try:
                                            time.sleep(delay)  # wait before replying
                                            send_resp = requests.post(
                                                f"{API_BASE}/channels/{channel_id}/messages",
                                                headers=headers,
                                                json={"content": reply_message}
                                            )
                                            if send_resp.status_code in (200, 201):
                                                self.log(f"‚úÖ Replied to DM from {author_id}.")
                                                replied_users.add(author_id)
                                            else:
                                                self.log(f"‚ùå Failed to reply DM: {send_resp.status_code}")
                                        except Exception as e:
                                            self.log(f"‚ùå Exception sending DM reply: {e}")

                        except Exception as e:
                            self.log(f"‚ùå WebSocket Error: {e}")
                            await asyncio.sleep(5)

            except Exception as e:
                self.log(f"‚ùå Could not connect to Discord Gateway: {e}")

        asyncio.run(run_gateway())
    # -------- Sound --------
    def play_opening_sound(self):
        try:
            pygame.mixer.music.load("opening_sound.wav")
            pygame.mixer.music.play()
        except Exception as e:
            self.log(f"‚ùå Error playing opening sound: {e}")

    # -------- On close --------
    def on_close(self):
        self.send_running = False
        self.auto_reply_running = False
        self.root.destroy()


def main():
    root = tk.Tk()
    app = DiscordBotGUI(root)
    root.mainloop()

def main_app(token):
     main()



if __name__ == "__main__":
    token = check_activation()  # This will exit if invalid
    main_app(token)             # Only called if valid token with role

